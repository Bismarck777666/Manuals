1.WsClientConnection 에서 onReceive함수로 받아서 websocketClientHandler로 보낸다.(수신자료는 바이트배열)
2.onReceiveData에서 받은 자료을 처리한다.
   수신된 바이트 배열자료로부터 GITWireProtocol의 CreateMessages을 이용하여 메세지를 만들어 메세지 규칙에 맞는가를 본다.
3.GITWireProtocol의 CreateMessages에서 메시지 만드는 과정
   수신된   바이트베열을 모드 스트림에 써넣는다.
   ReadSingleMessage함수 가능한 모든 메세지를 읽어서 메세지콜렉션에 써넣는다,
   -스트림의 읽는 위치를 맨앞으로 놓는다.
   -머리부의 길이는 6바이트(시그네이쳐 1,메시지코드1,본체길이4)
   -스트림의 길이가 머리부길이(6)보다 작으면 false귀환 그렇지 않으면 다음 단계로 이동
   -스트림의 첫1바이트를 읽어서 시그네이쳐가 약속과 맞지않으면 isMalformed 를 true로 설정하고 탈퇴.맞으면 아래단계로 이
   -메세지코드와 본체길이를 읽는다.
   -본체길이가 MaxMessageLength(256 * 1024)보다 작으면 serializedMessageBytes 에 스트림을 본체길이만큼 바이트배열로 읽어서 넣는다.
   -위에서 얻은 메시지코드와,serializedMessageBytes 를 파라메터로하는 ParseMessage함수를 이용하여 메시지를 파싱한다.
   - isMalformed 가 false이면(이것은 메시지의 시그네이쳐는 맞는데 본체길이가 최대메시지길이보다 길때 즉 메시지가 꺾여서 올때)
     remainingBytes(남아있는 배이트배열)이라는 변수에다가 현제파케트의 길이에서 
     현재위치를 던값(즉 본체에서 현제 파케트에 있는 부분이라고 이해하면됨)을 읽는다.
     receiveMemoryStream(이것은 아까 위에서 이용하단 메모리 스트림이다.)을 다시 새로 창조한다.
    그리고는 true를 귀환해주어 다음번 메시지를 파싱할때 이함수를 호출할수있게 해준다.
   -isMailformed가 true 이면 false를 귀환해주어 다음번 메시지호츨때 이 메써드를 다시 호출을 못하게 해준다.(이것은 시그네이쳐가 맞지않을때 발생한다.)
   -이전단계에서 true를 귀환해준것으로 하여 본체길이에 해당하는 파켔을 다 받을때 까지 메모리스트림은 이전에 들어온 바이트 배열을 보관하고 있게된다.
   종당에는 메시지를 다읽어서 파싱단계롤 넘어간다.
4.GITGameMessage의 ParseMessage로 메시지 파싱하기.
   -본체의 바이트배열을 읽어서 분석을 진행하여 데이터 배열과 데이터타입배열에 각각 추가해준다.(두배열의 길이는 같을수 밖에 없다.)
   타입 한바이트가 있고 그다음에는 해당 타임에 따르는 데이터가 있기때문에...
5.메시지파싱이 끝나면 messages라는 메시지 배열에 메시지를 추가해준다.
6.5단계의 결과늘 3단계의 CreateMessage함수에서 귀환해준다.
7.그결과를 23단계의 onReceive함수에서 받아서 이 메시지를 연결상태가 콘넥상태이면 로긴요청과 허트비트요청만을 허용하는 
   onProcMessageBeforeAuth함수를 호출한다.
   연결상태가 인증대기상태이면 허트비트만을 허용하는 onProcMessageWaitAuth를 호출해준다.
   만을 연결상태가 의의 두상태가 아니라면(인증되였다면) 해당 유저의 액터가 이미전에 창조되였으므로 해당 액터에 메시지를 보낸다.